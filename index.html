<!doctype html><html lang="ja"><head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>NOTE LINK — v0.8.0 / B-REL6-HF6l</title>
<style>
:root{
  --ink:#e6f1ff;--ink-dim:#a6c2e8;--bg:#0b1020;--panel:#101827;--accent:#3f78ff;--ok:#20e3c2;--muted:#2a3550;
  --topbar-h:46px;--toolbar-w:56px;--sheet:#fff;--sheet-shadow:0 6px 28px rgba(0,0,0,.45)
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif;-webkit-user-select:none;user-select:none}

/* ========== Top bar ========== */
header.topbar{position:fixed;z-index:1000;left:0;right:0;top:0;height:var(--topbar-h);display:flex;align-items:center;gap:8px;padding:6px 10px;background:#324a8d;/*既存風*/background:linear-gradient(0deg,rgba(42,84,255,.16),rgba(42,84,255,.16)),var(--accent);border-bottom:1px solid #ffffff26}
.topbar .brand{font-weight:700}
.topbar .sp{flex:1}
.topbar .btn{height:30px;min-width:36px;padding:0 10px;border-radius:10px;border:1px solid #ffffff38;background:#ffffff2d;color:#fff;display:inline-flex;align-items:center;justify-content:center;gap:6px}
.topbar .btn:active{transform:translateY(1px)}
.topbar .btn.small{min-width:auto;padding:0 8px}
.topbar .group{display:inline-flex;gap:6px;align-items:center}
#build{opacity:.75;font-size:12px}

/* オーバーフロー … */
#overflowBtn{display:none}
@media (max-width:980px){
  #pagerBlock{display:none}
  #overflowBtn{display:inline-flex}
}

/* ========== Stage ========== */
#wrap{position:relative;height:100%;padding-top:var(--topbar-h)}
#stage{position:absolute;inset:0;padding-left:var(--toolbar-w)}
#viewport{position:absolute;inset:0;transform-origin:0 0;touch-action:none}

/* Sidebar（既存風） */
.sidebar{position:fixed;z-index:900;left:0;top:var(--topbar-h);bottom:0;width:var(--toolbar-w);display:flex;flex-direction:column;align-items:center;background:rgba(0,0,0,.86);box-shadow:0 0 0 1px var(--muted) inset}
.sidebar .rail{width:100%;padding:6px;display:flex;flex-direction:column;gap:8px}
.tool{display:grid;place-items:center;width:100%;height:36px;border-radius:10px;cursor:pointer;background:rgba(22,26,38,.75);border:1px solid rgba(50,60,100,.6);outline:1px solid rgba(79,124,255,.35)}
.tool.active{outline-color:var(--ok)}
.tool svg{width:18px;height:18px;stroke:var(--ink);fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round}

/* Panel（設定） */
.panel{position:absolute;z-index:950;left:70px;top:calc(var(--topbar-h) + 10px);min-width:300px;max-width:340px;padding:10px;border-radius:14px;color:var(--ink);background:var(--panel);border:1px solid #ffffff24;box-shadow:0 10px 24px rgba(0,0,0,.45);display:none;max-height:calc(100vh - 90px);overflow:auto}
.panel.show{display:block}
.panel .row{display:flex;align-items:center;gap:10px;margin:8px 0}
.panel .row label{width:110px;font-size:12px;color:var(--ink-dim)}
.panel .row input[type="range"]{flex:1}
.panel .row button{height:28px;padding:0 10px;border-radius:8px;border:1px solid #ffffff2e;background:#ffffff14;color:#fff}

/* canvases */
#pageBg,#grid,#guide,#paint{position:absolute;left:var(--toolbar-w);top:0;right:0;bottom:0}
#pageBg{z-index:60}#grid{z-index:70;pointer-events:none}#guide{z-index:80;pointer-events:none}#paint{z-index:90;touch-action:none;-webkit-touch-callout:none}

/* A4 sheet frame */
#sheetBox{position:absolute;z-index:65;left:50%;top:50%;transform:translate(-50%,-50%);width:794px;height:1123px;background:var(--sheet);box-shadow:var(--sheet-shadow)}

/* text layer */
.text-layer{position:absolute;left:var(--toolbar-w);top:0;right:0;bottom:0;z-index:120;pointer-events:none}
.note-text{position:absolute;min-width:64px;min-height:28px;padding:6px 8px;color:#0b1020;background:#fff8;border:1px dashed #2238;border-radius:6px;pointer-events:auto}

/* overflow menu (⋯) */
#overflowMenu{position:fixed;right:10px;top:calc(var(--topbar-h) + 6px);background:var(--panel);border:1px solid #ffffff24;border-radius:12px;box-shadow:0 10px 24px rgba(0,0,0,.45);padding:8px;display:none;z-index:1200}
#overflowMenu button{display:block;width:100%;text-align:left;margin:4px 0}

/* debug chip */
#dbg{position:fixed;right:10px;bottom:10px;background:#ffffff22;border:1px solid #ffffff3a;border-radius:10px;padding:6px 10px;color:#fff;font-size:12px;cursor:pointer}

@media print{header.topbar,.sidebar,#overflowMenu,#dbg{display:none!important}#stage{padding-left:0!important}#wrap{padding-top:0}#sheetBox{box-shadow:none}}
</style>
</head>
<body>
<header class="topbar" id="topbar">
  <strong class="brand">NOTE LINK — v0.8.0 / B-REL6-HF6l</strong>
  <div class="group">
    <button class="btn" id="btnAddImg">画像追加</button>
    <button class="btn" id="btnInsertImg">画像挿入</button>
    <button class="btn" id="btnAddPage">＋ページ</button>
  </div>
  <div class="group">
    <button class="btn" id="btnLoad">読み込み</button>
    <button class="btn" id="btnSave">保存</button>
  </div>
  <div class="group">
    <button class="btn small" id="btnZoomOut">−</button>
    <button class="btn small" id="btnZoomReset">100%</button>
    <button class="btn small" id="btnZoomIn">＋</button>
  </div>
  <div class="group">
    <button class="btn small" id="btnUndo">undo</button>
    <button class="btn small" id="btnRedo">redo</button>
    <button class="btn small" id="btnPrint">印刷</button>
    <button class="btn small" id="btnPng">PNG</button>
    <button class="btn small" id="btnShare">共有</button>
  </div>
  <div class="group" id="pagerBlock">
    <button class="btn small" id="btnPrev">◀ 前</button>
    <span id="pageInfo">1/1</span>
    <button class="btn small" id="btnNext">次 ▶</button>
  </div>
  <span class="sp"></span>
  <button class="btn" id="overflowBtn">⋯</button>
  <span id="build">build: HF6l</span>
</header>

<div id="overflowMenu">
  <button class="btn" id="omPrev">◀ 前</button>
  <button class="btn" id="omNext">次 ▶</button>
  <button class="btn" id="omAddPage">＋ページ</button>
  <button class="btn" id="omSetBg">画像を背景に設定</button>
</div>

<aside class="sidebar">
  <div class="rail">
    <button class="tool" data-tool="pen" id="tPen" title="ペン"><svg viewBox="0 0 24 24"><path d="M3 21l4-1 12-12-3-3L4 17l-1 4zM14 6l3 3"/></svg></button>
    <button class="tool" data-tool="marker" id="tMarker" title="マーカー"><svg viewBox="0 0 24 24"><path d="M3 16l10-10 5 5-10 10-5 1 1-6zM13 6l5 5"/></svg></button>
    <button class="tool" data-tool="eraser" id="tEraser" title="消しゴム"><svg viewBox="0 0 24 24"><path d="M3 15l8-8 6 6-6 6H7zM13 7l4 4"/></svg></button>
    <button class="tool" data-tool="hand" id="tHand" title="パン"><svg viewBox="0 0 24 24"><path d="M9 11V6a2 2 0 0 1 4 0v5M13 11V5a2 2 0 1 1 4 0v8M9 11a2 2 0 0 1 4 0v8l-2 2-4-4-2-6 2-1z"/></svg></button>
    <button class="tool" data-tool="keyboard" id="tText" title="テキスト"><svg viewBox="0 0 24 24"><rect x="3" y="7" width="18" height="10" rx="2"/><path d="M7 10h10M5 13h14"/></svg></button>
    <button class="tool" data-tool="settings" id="tSettings" title="設定"><svg viewBox="0 0 24 24"><path d="M12 7.5a4.5 4.5 0 1 1 0 9 4.5 4.5 0 0 1 0-9zM4 13h2l1 2-1 2H4l-1-2 1-2zm14 0h2l1 2-1 2h-2l-1-2 1-2zM8 4h2l2 1 2-1h2l1 2-1 2h-2l-2-1-2 1H8L7 6l1-2z"/></svg></button>
  </div>
</aside>

<!-- 設定パネル（最小） -->
<div class="panel" id="panel">
  <div style="font-weight:600;margin-bottom:6px">ツール設定</div>
  <div class="row"><label>色</label><input type="color" id="uiColor" value="#000000"></div>
  <div class="row"><label>太さ</label><input type="range" id="uiSize" min="1" max="60" value="4"><span id="uiSizeVal">4px</span></div>
  <div class="row"><label>不透明度（マーカー）</label><input type="range" id="uiAlpha" min="10" max="100" value="50"><span id="uiAlphaVal">50%</span></div>
  <div class="row"><label>直線モード</label><label><input type="checkbox" id="uiStraight">（モバイル）</label></div>
  <div class="row"><label>グリッド</label><label><input type="checkbox" id="uiGrid" checked> 表示</label>
    <select id="uiGridStep"><option value="5">5mm</option><option value="10" selected>10mm</option><option value="15">15mm</option></select>
  </div>
  <div class="row"><label>テキスト</label><button id="btnTextAdd">追加</button></div>
</div>

<div id="wrap"><div id="stage">
  <div id="viewport">
    <!-- A4 sheet visual (for centering) -->
    <div id="sheetBox"></div>
    <canvas id="pageBg"></canvas>
    <canvas id="grid"></canvas>
    <canvas id="guide"></canvas>
    <canvas id="paint"></canvas>
    <div class="text-layer" id="textLayer"></div>
  </div>
</div></div>

<div id="dbg" title="Alt+D">debug</div>

<script>
/* ===== Helpers ===== */
const $=s=>document.querySelector(s), $$=s=>Array.from(document.querySelectorAll(s));
const DPR = Math.max(1, self.devicePixelRatio||1);
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
function mmToPx(mm){return mm*96/25.4}
function pxToMm(px){return px*25.4/96}

/* ===== Elements ===== */
const viewport=$('#viewport');
const cvBg=$('#pageBg'), ctxBg=cvBg.getContext('2d');
const cvGrid=$('#grid'), ctxGrid=cvGrid.getContext('2d');
const cvGuide=$('#guide'), ctxGuide=cvGuide.getContext('2d');
const cv=$('#paint'), ctx=cv.getContext('2d');
const sheet=$('#sheetBox');
const textLayer=$('#textLayer');

/* ===== State ===== */
let zoom=1, panX=0, panY=0; // world transform
let W=0, H=0; // logical viewport size in CSS px
let tool='pen';
const perTool={pen:{color:'#000000',size:4,alpha:1},marker:{color:'#ffff00',size:16,alpha:.5},eraser:{size:24},hand:{},keyboard:{}};
let color=perTool.pen.color, size=perTool.pen.size, alpha=perTool.marker.alpha;
let gridOn=true, gridStepMM=10;
let straightToggle=false, straightKey=false;
let pages=[{bg:null, strokes:[], texts:[]}];
let pageIndex=0;
let history=[], redo=[];

/* ===== Layout ===== */
function applyTopbar(){ const h=Math.round($('#topbar').getBoundingClientRect().height)||46; document.documentElement.style.setProperty('--topbar-h',h+'px'); }
function resizeCanvases(){ const r=viewport.getBoundingClientRect(); W=r.width; H=r.height; for(const c of [cvBg,cvGrid,cvGuide,cv]){ c.width=Math.round(W*DPR); c.height=Math.round(H*DPR); c.style.width=W+'px'; c.style.height=H+'px'; }
  drawGrid(); render(); }
function applyTransform(){ viewport.style.transform=`translate(${panX}px,${panY}px) scale(${zoom})`; }
function centerSheet(){ // keep sheet centered under transform basis
  const r=viewport.getBoundingClientRect(); const sw=794, sh=1123; sheet.style.width=sw+'px'; sheet.style.height=sh+'px'; sheet.style.left='50%'; sheet.style.top='50%'; sheet.style.transform='translate(-50%,-50%)'; }

/* ===== Zoom (center-fixed) ===== */
function zoomAt(newZoom, cx, cy){ const rect=viewport.getBoundingClientRect(); const prev=zoom; newZoom=clamp(newZoom,0.5,3);
  const ox = (cx - rect.left - panX) / prev; // world coords before
  const oy = (cy - rect.top  - panY) / prev;
  zoom = newZoom;
  panX = cx - rect.left - ox * zoom;
  panY = cy - rect.top  - oy * zoom;
  applyTransform(); drawGrid(); }
const centerPoint=()=>{ const r=viewport.getBoundingClientRect(); return {x:r.left + r.width/2, y:r.top + r.height/2}; };
$('#btnZoomIn').onclick=()=>{ const c=centerPoint(); zoomAt(zoom+0.1, c.x, c.y); updateZoomText(); };
$('#btnZoomOut').onclick=()=>{ const c=centerPoint(); zoomAt(zoom-0.1, c.x, c.y); updateZoomText(); };
$('#btnZoomReset').onclick=()=>{ const c=centerPoint(); zoomAt(1, c.x, c.y); updateZoomText(); };
function updateZoomText(){ $('#btnZoomReset').textContent=Math.round(zoom*100)+'%'; }

/* ===== Grid ===== */
function drawGrid(){ ctxGrid.clearRect(0,0,cvGrid.width,cvGrid.height); if(!gridOn) return; const step=mmToPx(gridStepMM)*DPR; const s=ctxGrid; s.save(); s.strokeStyle='#62709c55'; s.lineWidth=1; s.beginPath(); const oy=0.5*DPR; for(let y=oy;y<=cvGrid.height;y+=step){ s.moveTo(0,y); s.lineTo(cvGrid.width,y);} s.stroke(); s.restore(); }

/* ===== Tool switching ===== */
function setTool(t){
  saveToolState(tool); tool=t; loadToolState(t);
  $$('.tool').forEach(b=>b.classList.toggle('active', b.dataset.tool===t));
  $('#panel').classList.toggle('show', false);
  syncUI();
  cv.style.cursor=(t==='hand')?'grab':'crosshair';
}
function saveToolState(k){const p=perTool[k]||(perTool[k]={}); p.color=color; p.size=size; if(k==='marker') p.alpha=alpha;}
function loadToolState(k){const p=perTool[k]||{}; color=p.color ?? color; size=p.size ?? size; if(k==='marker') alpha=p.alpha ?? alpha;}
$$('.tool').forEach(btn=>btn.addEventListener('click',()=>{ const t=btn.dataset.tool; if(t==='settings'){ $('#panel').classList.toggle('show'); return;} setTool(t);}));

/* ===== Panel UI ===== */
const ui={color:$('#uiColor'), size:$('#uiSize'), alpha:$('#uiAlpha'), sizeVal:$('#uiSizeVal'), alphaVal:$('#uiAlphaVal'), straight:$('#uiStraight'), grid:$('#uiGrid'), step:$('#uiGridStep')};
function syncUI(){ ui.color.value=color; ui.size.value=size; ui.sizeVal.textContent=`${size}px (${pxToMm(size).toFixed(2)}mm)`; ui.alpha.value=Math.round(alpha*100); ui.alphaVal.textContent=Math.round(alpha*100)+'%'; ui.straight.checked=straightToggle; ui.grid.checked=gridOn; ui.step.value=String(gridStepMM); }
Object.values(ui).forEach(el=> el.addEventListener('input', ()=>{ color=ui.color.value; size=+ui.size.value; ui.sizeVal.textContent=`${size}px (${pxToMm(size).toFixed(2)}mm)`; alpha=+ui.alpha.value/100; ui.alphaVal.textContent=Math.round(alpha*100)+'%'; straightToggle=ui.straight.checked; gridOn=ui.grid.checked; gridStepMM=+ui.step.value; drawGrid(); }));
$('#btnTextAdd').onclick=()=>addText();

/* ===== Pages ===== */
function pageInfo(){ $('#pageInfo').textContent=(pageIndex+1)+'/'+pages.length; }
function addPageAt(idx){ pages.splice(idx,0,{bg:null,strokes:[],texts:[]}); pageIndex=idx; render(); pageInfo(); }
function addPageEnd(){ addPageAt(pages.length); }
function switchPage(i){ i=clamp(i,0,pages.length-1); if(i===pageIndex) return; pageIndex=i; render(); pageInfo(); }
$('#btnAddPage').onclick=()=>addPageAt(pageIndex+1);
$('#btnPrev').onclick=()=>switchPage(pageIndex-1); $('#btnNext').onclick=()=>switchPage(pageIndex+1);
$('#overflowBtn').onclick=()=>{ const m=$('#overflowMenu'); m.style.display=(m.style.display==='block'?'none':'block'); };
$('#omPrev').onclick=()=>{ $('#overflowMenu').style.display='none'; switchPage(pageIndex-1)};
$('#omNext').onclick=()=>{ $('#overflowMenu').style.display='none'; switchPage(pageIndex+1)};
$('#omAddPage').onclick=()=>{ $('#overflowMenu').style.display='none'; addPageAt(pageIndex+1)};
$('#omSetBg').onclick=()=>{ $('#overflowMenu').style.display='none'; setBackgroundForCurrent(); };

/* ===== Rendering ===== */
function clearAll(){ ctx.clearRect(0,0,cv.width,cv.height); ctxBg.clearRect(0,0,cvBg.width,cvBg.height); ctxGuide.clearRect(0,0,cvGuide.width,cvGuide.height); }
function fitA4InCanvas(){ // draw white A4 centered to Bg canvas
  ctxBg.save(); ctxBg.fillStyle='#fff';
  const r=viewport.getBoundingClientRect(); const sw=794*DPR, sh=1123*DPR; // A4@96dpi
  // place sheetBox already centers visually; here bg canvas just cleared (white area drawn by sheetBox); background images will be drawn on cvBg aligned to sheetBox
  ctxBg.restore(); }
async function drawBackground(){ ctxBg.clearRect(0,0,cvBg.width,cvBg.height); // white page rectangle
  const r=sheet.getBoundingClientRect(); const v=viewport.getBoundingClientRect();
  const x=(r.left - v.left)*DPR, y=(r.top - v.top)*DPR, w=r.width*DPR, h=r.height*DPR;
  // base white page
  ctxBg.save(); ctxBg.fillStyle='#fff'; ctxBg.fillRect(x,y,w,h); ctxBg.restore();
  const bg = pages[pageIndex].bg; if(!bg) return;
  // draw bg image fit into A4 box
  try{
    const img = await loadImage(bg); const fit = fitContain(img.width, img.height, w, h);
    ctxBg.drawImage(img, 0,0,img.width,img.height, x+fit.dx, y+fit.dy, fit.dw, fit.dh);
  }catch(e){ console.warn('bg decode fail',e); }
}
function fitContain(iw, ih, bw, bh){ const s=Math.min(bw/iw, bh/ih); const dw=iw*s, dh=ih*s; return {dw, dh, dx:(bw-dw)/2, dy:(bh-dh)/2}; }
function renderStrokes(){ ctx.clearRect(0,0,cv.width,cv.height); const r=viewport.getBoundingClientRect(); const sb=sheet.getBoundingClientRect(); const offX=(sb.left - r.left)*DPR, offY=(sb.top - r.top)*DPR, w=sb.width*DPR, h=sb.height*DPR; ctx.save(); ctx.beginPath(); ctx.rect(offX,offY,w,h); ctx.clip(); ctx.restore();
  const list=pages[pageIndex].strokes; for(const s of list){ drawStroke(ctx,s); } }
function renderTexts(){ textLayer.innerHTML=''; const list=pages[pageIndex].texts||[]; for(const t of list){ const el=document.createElement('div'); el.className='note-text'; el.contentEditable='true'; el.style.left=t.x+'px'; el.style.top=t.y+'px'; el.textContent=t.text||'テキスト'; el.oninput=()=>{ t.text=el.textContent; pushHistory(); }; textLayer.appendChild(el);} }
function render(){ clearAll(); fitA4InCanvas(); drawBackground(); renderStrokes(); renderTexts(); pageInfo(); }

/* ===== Image loading ===== */
function loadImage(src){ return new Promise((res,rej)=>{ const img=new Image(); img.onload=()=>{ if(img.decode) img.decode().then(()=>res(img)).catch(()=>res(img)); else res(img); }; img.onerror=rej; img.src=src; }); }

/* ===== Input Mapping & Drawing ===== */
function setCtxForStroke(s){ if(s.tool==='eraser'){ ctx.globalCompositeOperation='destination-out'; ctx.globalAlpha=1; ctx.strokeStyle='#000'; }
  else if(s.tool==='marker'){ ctx.globalCompositeOperation='source-over'; ctx.strokeStyle=s.color; ctx.globalAlpha=0.5; }
  else { ctx.globalCompositeOperation='source-over'; ctx.strokeStyle=s.color; ctx.globalAlpha=1; }
  ctx.lineWidth=s.size*DPR; ctx.lineCap='round'; ctx.lineJoin='round'; }
function drawStroke(target, s){ target.save(); if(s.tool==='eraser'){ target.globalCompositeOperation='destination-out'; target.globalAlpha=1; target.strokeStyle='#000'; } else if(s.tool==='marker'){ target.globalCompositeOperation='source-over'; target.globalAlpha=0.5; target.strokeStyle=s.color; } else { target.globalCompositeOperation='source-over'; target.globalAlpha=1; target.strokeStyle=s.color; } target.lineWidth=s.size*DPR; target.lineCap='round'; target.lineJoin='round';
  if(s.kind==='line'){
    target.beginPath(); target.moveTo(s.x1, s.y1); target.lineTo(s.x2, s.y2); target.stroke();
  }else{
    const pts=s.pts; if(!pts||pts.length<2) return; target.beginPath(); target.moveTo(pts[0].x, pts[0].y); for(let i=1;i<pts.length-1;i++){ const p=pts[i], n=pts[i+1]; const mx=(p.x+n.x)/2, my=(p.y+n.y)/2; target.quadraticCurveTo(p.x,p.y,mx,my);} const last=pts[pts.length-1]; target.lineTo(last.x,last.y); target.stroke();
  }
  target.restore(); }

// pointer mapping inside sheet
function pt(e){ const vr=viewport.getBoundingClientRect(); const sr=sheet.getBoundingClientRect(); const x=((e.clientX - vr.left) - (sr.left - vr.left)) * DPR; const y=((e.clientY - vr.top)  - (sr.top  - vr.top )) * DPR; return {x, y}; }

// Palm reject
let penActive=false, penId=null, touchCount=0;
function shouldReject(e){ if(e.pointerType==='pen') return false; if(penActive) return true; if(e.pointerType==='touch' && touchCount>=1) return true; return false; }

let drawing=false, straight=false, start=null, last=null, curStroke=null;
cv.addEventListener('pointerdown', (e)=>{ if(e.pointerType==='touch') touchCount++; if(shouldReject(e)) return; if(tool==='hand'){ cv.setPointerCapture(e.pointerId); cv.style.cursor='grabbing'; panning=true; panLast={x:e.clientX,y:e.clientY}; return; }
  if(e.pointerType==='pen'){ penActive=true; penId=e.pointerId; }
  e.preventDefault(); cv.setPointerCapture(e.pointerId);
  straight = !!straightKey || straightToggle;
  start = toCanvas(pt(e)); last = start; drawing=true; curStroke = { tool, color:(tool==='marker'? (perTool.marker.color||'#ffff00') : color), size:(tool==='marker'? perTool.marker.size : size), kind: (straight? 'line' : 'path'), pts: straight? null : [start], x1:null,y1:null,x2:null,y2:null };
  if(straight){ ctxGuide.clearRect(0,0,cvGuide.width,cvGuide.height); }
  pushHistory();
},{passive:false});

function toCanvas(p){ // clamp to A4
  const sr=sheet.getBoundingClientRect(); const vr=viewport.getBoundingClientRect(); const offX=(sr.left - vr.left)*DPR, offY=(sr.top - vr.top)*DPR; const w=sr.width*DPR, h=sr.height*DPR; const x=clamp(p.x,0,w), y=clamp(p.y,0,h); return {x:offX+x, y:offY+y}; }

cv.addEventListener('pointermove', (e)=>{
  if(tool==='hand' && panning){ if(!panLast){panLast={x:e.clientX,y:e.clientY}} const dx=e.clientX-panLast.x, dy=e.clientY-panLast.y; panX+=dx; panY+=dy; panLast={x:e.clientX,y:e.clientY}; applyTransform(); return; }
  if(!drawing) return; const list=(e.getCoalescedEvents && e.getCoalescedEvents())||[e]; if(straight){ const p=toCanvas(pt(e)); ctxGuide.clearRect(0,0,cvGuide.width,cvGuide.height); ctxGuide.save(); ctxGuide.strokeStyle='#7ec8ff'; ctxGuide.lineWidth=(curStroke.size||size)*DPR; ctxGuide.setLineDash([6*DPR,6*DPR]); ctxGuide.beginPath(); ctxGuide.moveTo(start.x,start.y); ctxGuide.lineTo(p.x,p.y); ctxGuide.stroke(); ctxGuide.restore(); last=p; }
  else{ for(const ev of list){ const p=toCanvas(pt(ev)); curStroke.pts.push(p); last=p; } ctx.save(); setCtxForStroke(curStroke); // incremental draw for feedback
    const pts=curStroke.pts; const L=pts.length; if(L>=3){ const p=pts[L-2], n=pts[L-1]; const mx=(p.x+n.x)/2, my=(p.y+n.y)/2; ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.quadraticCurveTo(p.x,p.y,mx,my); ctx.stroke(); } else if(L===2){ ctx.beginPath(); ctx.moveTo(pts[0].x,pts[0].y); ctx.lineTo(pts[1].x,pts[1].y); ctx.stroke(); }
    ctx.restore(); }
},{passive:true});

cv.addEventListener('pointerup', (e)=>{
  if(e.pointerType==='touch') touchCount=Math.max(0,touchCount-1);
  if(tool==='hand' && panning){ panning=false; cv.style.cursor='grab'; panLast=null; return; }
  if(!drawing){ ctxGuide.clearRect(0,0,cvGuide.width,cvGuide.height); return; }
  if(straight){ const p=toCanvas(pt(e)); curStroke.x1=start.x; curStroke.y1=start.y; curStroke.x2=p.x; curStroke.y2=p.y; ctxGuide.clearRect(0,0,cvGuide.width,cvGuide.height); pages[pageIndex].strokes.push(curStroke); renderStrokes(); }
  else{ pages[pageIndex].strokes.push(curStroke); }
  drawing=false; curStroke=null; if(e.pointerType==='pen' && e.pointerId===penId){ penActive=false; penId=null; }
},{passive:true});
cv.addEventListener('pointercancel',()=>{ drawing=false; curStroke=null; ctxGuide.clearRect(0,0,cvGuide.width,cvGuide.height); });
addEventListener('keydown',e=>{ if(e.key==='Shift') straightKey=true; }); addEventListener('keyup',e=>{ if(e.key==='Shift') straightKey=false; });

// Pan (hand)
let panning=false, panLast=null;

/* ===== Text ===== */
function addText(){ const sr=sheet.getBoundingClientRect(); const vr=viewport.getBoundingClientRect(); const x= (sr.left - vr.left) + 40; const y= (sr.top - vr.top) + 40; const el=document.createElement('div'); el.className='note-text'; el.contentEditable='true'; el.style.left=x+'px'; el.style.top=y+'px'; el.textContent='テキスト'; const model={x, y, text:'テキスト'}; pages[pageIndex].texts.push(model); el.oninput=()=>{ model.text=el.textContent; pushHistory(); }; textLayer.appendChild(el); el.focus(); }

/* ===== Undo/Redo ===== */
function snapshot(){ return JSON.stringify({pages, pageIndex}); }
function restore(json){ const obj=JSON.parse(json); pages=obj.pages; pageIndex=obj.pageIndex||0; render(); }
function pushHistory(){ history.push(snapshot()); if(history.length>50) history.shift(); redo.length=0; }
$('#btnUndo').onclick=()=>{ const prev=history.pop(); if(!prev) return; redo.push(snapshot()); restore(prev); };
$('#btnRedo').onclick=()=>{ const nxt=redo.pop(); if(!nxt) return; history.push(snapshot()); restore(nxt); };

/* ===== Save/Load ===== */
async function saveFile(){ const data=snapshot(); const blob=new Blob([data],{type:'application/json'}); if('showSaveFilePicker' in window){ try{ const handle=await window.showSaveFilePicker({suggestedName:'note-link.json',types:[{description:'Note Link JSON',accept:{'application/json':['.json']}}]}); const w=await handle.createWritable(); await w.write(blob); await w.close(); }catch(e){ fallback(); } } else fallback(); function fallback(){ const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='note-link.json'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),800); } }
async function loadFile(){ try{ let file=null; if('showOpenFilePicker' in window){ const [h]=await window.showOpenFilePicker({types:[{description:'Note Link JSON',accept:{'application/json':['.json']}}]}); file=await h.getFile(); } else { const i=document.createElement('input'); i.type='file'; i.accept='.json,application/json'; const p=new Promise(r=>i.onchange=()=>r(i.files[0]||null)); i.click(); file=await p; } if(!file) return; const txt=await file.text(); restore(txt); // ensure bg decoded
  await drawBackground(); renderStrokes(); }
  catch(e){ alert('読み込み失敗: '+e.message); }
}
$('#btnSave').onclick=saveFile; $('#btnLoad').onclick=loadFile;

/* ===== Images ===== */
async function pickImage(){ return new Promise((res)=>{ const i=document.createElement('input'); i.type='file'; i.accept='image/*'; i.onchange=()=>{ const f=i.files&&i.files[0]; if(!f){res(null);return;} const r=new FileReader(); r.onload=()=>res(r.result); r.readAsDataURL(f); }; i.click(); }); }
async function addImageAsPage(mode){ const data=await pickImage(); if(!data) return; if(mode==='append'){ addPageEnd(); } else if(mode==='insert'){ addPageAt(pageIndex+1); } pages[pageIndex].bg=data; render(); }
async function setBackgroundForCurrent(){ const data=await pickImage(); if(!data) return; pages[pageIndex].bg=data; await drawBackground(); }
$('#btnAddImg').onclick=()=>addImageAsPage('append'); $('#btnInsertImg').onclick=()=>addImageAsPage('insert');

/* ===== Output PNG / Print / Share ===== */
function compositeCanvas(){ const out=document.createElement('canvas'); out.width=cv.width; out.height=cv.height; const o=out.getContext('2d'); // paint bg (pageBg already has white + background image)
  o.drawImage(cvBg,0,0); o.drawImage(cv,0,0); // texts (rough)
  [...textLayer.children].forEach(n=>{ const r=n.getBoundingClientRect(), L=textLayer.getBoundingClientRect(); const x=((r.left-L.left)*DPR), y=((r.top-L.top)*DPR)+16; o.fillStyle='#111'; o.font=(16*DPR)+'px system-ui'; o.fillText(n.textContent.trim(),x,y); }); return out; }
$('#btnPng').onclick=()=>compositeCanvas().toBlob(b=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='note-link.png'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),800); });
$('#btnPrint').onclick=()=>window.print();
$('#btnShare').onclick=()=>{ compositeCanvas().toBlob(async b=>{ const f=new File([b],'note.png',{type:'image/png'}); if(navigator.share&&navigator.canShare&&navigator.canShare({files:[f]})){ try{ await navigator.share({files:[f],title:'Note Link'});}catch(e){} } else { const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='note-link.png'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),800); } }); };

/* ===== Init ===== */
function boot(){ applyTopbar(); centerSheet(); resizeCanvases(); applyTransform(); setTool('pen'); syncUI(); pageInfo(); }
addEventListener('resize',()=>{ applyTopbar(); resizeCanvases(); });
addEventListener('orientationchange',()=>setTimeout(()=>{ applyTopbar(); resizeCanvases(); },80));

// debug chip toggles overflow menu for quick check
$('#dbg').onclick=()=>{ const m=$('#overflowMenu'); m.style.display=(m.style.display==='block'?'none':'block'); };
addEventListener('keydown',e=>{ if(e.altKey && (e.key==='d'||e.key==='D')) $('#dbg').click(); if(e.key==='ArrowLeft') $('#btnPrev').click(); if(e.key==='ArrowRight') $('#btnNext').click(); });

boot();
</script>
</body></html>
