<!doctype html><html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>NOTE LINK — v0.8.0 / B-REL6-M</title>
<!--
PATCH: 2025-09-28 07:42 JST / VERSION HF6M
CHANGES:
  - Move fades/hint outside the scroll area (rail-wrap) so they stay fixed
  - Thinner header scrollbar on PC hover (4px). Firefox stays "thin"
-->
<style>
:root{
  --ink:#e6f1ff;--ink-dim:#9bd6e9;--bg:#0b1020;--panel:#101827;--accent:#3f78ff;
  --ok:#20e3c2;--muted:#2a3550;--shadow:0 10px 24px rgba(0,0,0,.45);
  --topbar-h:44px;--toolbar-w:56px
}
*{box-sizing:border-box}
html,body{
  height:100%;margin:0;background:var(--bg);color:var(--ink);
  font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif;
  -webkit-user-select:none;user-select:none;
  overflow-x:hidden;
}
header.topbar{
  position:fixed;top:0;left:0;right:0;z-index:2000;height:var(--topbar-h);
  display:flex;align-items:center;gap:8px;padding:0 10px;font-size:12px;color:#fff;
  background:linear-gradient(0deg,rgba(42,84,255,.16),rgba(42,84,255,.16)),var(--accent);
  border-bottom:1px solid #ffffff26; white-space:nowrap;
  padding-top:env(safe-area-inset-top);
  overflow:hidden;
}
.topbar .brand{flex:0 0 auto;font-weight:700}

/* ==== wrap（固定フェードの基準） ==== */
.topbar .rail-wrap{ position:relative; flex:1 1 auto; min-width:40px; }

/* 中央：横スクロール領域 */
.topbar .rail-scroll{
  flex:1 1 auto;
  overflow-x:auto; overflow-y:hidden;
  display:flex; align-items:center; gap:8px;
  white-space:nowrap;
  -webkit-overflow-scrolling:touch;
  scrollbar-width:none;
  cursor:grab; user-select:none; -webkit-user-select:none;
}
.topbar .rail-scroll::-webkit-scrollbar{display:none}
.topbar .rail-scroll.dragging{ cursor:grabbing }
.topbar .right-fixed{flex:0 0 auto;display:flex;align-items:center;gap:8px}
.topbar .btn{height:28px;padding:0 10px;border-radius:10px;background:#ffffff33;
  border:1px solid #ffffff38;color:#fff;display:inline-flex;align-items:center}
.topbar .btn:active{transform:translateY(1px)}
.build{opacity:.8}

/* ==== 固定フェード（wrap に固定、流れない） ==== */
.rail-fade{
  position:absolute; top:0; bottom:0; width:28px; pointer-events:none;
  opacity:0; transition:opacity .2s;
}
.rail-fade.left { left:0;  background:linear-gradient(to right, rgba(0,0,0,.35), rgba(0,0,0,0)); }
.rail-fade.right{ right:0; background:linear-gradient(to left,  rgba(0,0,0,.35), rgba(0,0,0,0)); }

/* オーバーフロー時のみ表示。位置に応じて片側OFF（wrapに付与） */
.rail-wrap.can-overflow:not(.at-start) .rail-fade.left{  opacity:.9; }
.rail-wrap.can-overflow:not(.at-end)   .rail-fade.right{ opacity:.9; }

/* 初回だけ表示する“スライド”ヒント（wrap中央に固定） */
.rail-hint{
  position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
  background:#0009; color:#fff; padding:2px 8px; border-radius:12px;
  font-size:11px; line-height:1.9; letter-spacing:.02em;
  pointer-events:none; opacity:0; transition:opacity .25s;
  box-shadow:0 4px 10px rgba(0,0,0,.25);
}
.rail-hint.show{ opacity:1; animation:railPulse 1.6s ease-in-out 2; }
@keyframes railPulse{
  0%,100%{ transform:translate(-50%,-50%) scale(1); }
  50%    { transform:translate(-50%,-50%) scale(1.06); }
}

/* PCホバー時のみ薄いスクロールバーを露出（さらに細く 4px） */
@media (hover:hover){
  .topbar .rail-scroll:hover{ scrollbar-width:thin; scrollbar-color:#ffffff66 transparent; }
  .topbar .rail-scroll:hover::-webkit-scrollbar{ height:4px; }
  .topbar .rail-scroll:hover::-webkit-scrollbar-thumb{
    background:#ffffff66; border-radius:6px;
  }
}

#wrap{position:relative;height:100%;padding-top:var(--topbar-h)}
#stage{position:absolute;inset:0;padding-left:var(--toolbar-w)}
#viewport{position:absolute;inset:0;transform-origin:0 0;touch-action:none}

.sidebar{position:fixed;z-index:1500;left:0;top:var(--topbar-h);bottom:0;width:var(--toolbar-w);
  display:flex;flex-direction:column;align-items:center;background:rgba(0,0,0,.86);
  box-shadow:0 0 0 1px var(--muted) inset}
.sidebar .rail{width:100%;padding:6px;display:flex;flex-direction:column;gap:8px}
.tool{display:grid;place-items:center;width:100%;height:36px;border-radius:10px;cursor:pointer;
  background:rgba(22,26,38,.75);border:1px solid rgba(50,60,100,.6);
  outline:1px solid rgba(79,124,255,.35);box-shadow:0 0 0 2px rgba(0,0,0,.12)}
.tool:hover{outline:1px solid rgba(79,124,255,.5)}
.tool.active{outline:1px solid var(--ok)}
.tool svg{width:18px;height:18px;stroke:var(--ink);fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round}
.sidebar.collapsed .rail>.tool:not([data-tool="toggle"]){display:none}
.tool[data-tool="toggle"] svg{transition:transform .2s}
.sidebar.collapsed .tool[data-tool="toggle"] svg{transform:rotate(180deg)}

.panel{position:absolute;z-index:1400;left:70px;top:calc(var(--topbar-h) + 10px);
  min-width:280px;max-width:320px;padding:8px 12px 10px;border-radius:14px;color:var(--ink);
  background:var(--panel);border:1px solid #ffffff24;box-shadow:var(--shadow);
  display:none;user-select:none;max-height:calc(100vh - var(--topbar-h) - 24px);overflow:auto}
.panel.show{display:block}
.panel .handle{position:sticky;top:0;display:flex;align-items:center;gap:8px;padding:8px 12px;
  margin:-8px -12px 8px;background:var(--panel);border-bottom:1px solid #ffffff20;border-radius:14px 14px 0 0;cursor:grab;touch-action:none}
#panelTool{flex:1;font-weight:600;font-size:14px;text-align:left}
.panel .close{margin-left:auto;height:26px;padding:0 10px;border-radius:8px;border:1px solid #ffffff2e;background:#ffffff14;color:#fff;font-size:14px}
.panel .row{display:flex;align-items:center;gap:10px;margin:6px 0}
.panel .row label{width:100px;font-size:12px;color:var(--ink-dim)}
.panel .row input[type="range"]{flex:1;min-width:120px}
.panel .row button{height:26px;padding:0 8px;border-radius:8px;border:1px solid #ffffff2e;background:#ffffff14;color:#fff;font-size:12px}

#paper,#guide,#paint{position:absolute;left:var(--toolbar-w);top:0;right:0;bottom:0}
#paper,#guide{z-index:100;pointer-events:none}
#paint{z-index:120;touch-action:none;-webkit-touch-callout:none}

.text-layer{position:absolute;left:var(--toolbar-w);top:0;right:0;bottom:0;z-index:130;pointer-events:none}
.note-text{position:absolute;min-width:64px;min-height:28px;padding:6px 8px;color:#111;background:transparent;
  outline:1px dashed #ffffff40;border-radius:6px;pointer-events:auto;
  -webkit-user-select:text; user-select:text; caret-color:auto}
.note-text[contenteditable="true"]:focus{outline:2px solid var(--ok)}
.note-text .del{position:absolute;right:-8px;top:-10px;font-size:11px;color:#fff;background:#0008;border:1px solid #fff3;border-radius:8px;padding:2px 6px;display:none}
.note-text:focus-within .del{display:block}

@media print{header.topbar,.sidebar,.panel{display:none!important}#stage{padding-left:0!important}body,html,#wrap{height:auto}}

.page-nav{display:inline-flex;gap:6px;align-items:center}
#pageIndicator{min-width:48px;text-align:center}

#morePanel{position:fixed;right:10px;top:calc(var(--topbar-h) + 6px);z-index:3000;display:none;
  background:var(--panel);border:1px solid #ffffff24;border-radius:12px;box-shadow:var(--shadow);padding:8px}
#morePanel .btn{margin:4px 0;display:block;width:100%}
</style>
</head>
<body>
<header class="topbar" id="topbar">
  <!-- 左：固定表示 -->
  <div class="brand"><strong id="verText">NOTE LINK — V0.8.0 / B-REL6-M</strong></div>

  <!-- 中央：wrap（固定フェード）+ scroll内ボタン -->
  <div class="rail-wrap" id="railWrap">
    <div class="rail-scroll" id="railScroll">
      <button class="btn" id="btnImgAppend">画像追加</button>
      <button class="btn" id="btnImgInsert">画像挿入</button>
      <button class="btn" id="btnLoad">読み込み</button>
      <button class="btn" id="btnSave">保存</button>

      <button class="btn" id="btnZoomOut">−</button>
      <button class="btn" id="btnZoomReset">100%</button>
      <button class="btn" id="btnZoomIn">＋</button>

      <button class="btn" id="btnUndo">undo</button>
      <button class="btn" id="btnRedo">redo</button>
      <button class="btn" id="btnPrint">印刷</button>
      <button class="btn" id="btnPng">PNG</button>
      <button class="btn" id="btnShare">共有</button>

      <span class="page-nav">
        <button class="btn" id="btnPrev">◀︎ 前</button>
        <span id="pageIndicator">1/1</span>
        <button class="btn" id="btnNext">次 ▶︎</button>
      </span>

      <span class="build" id="buildText">BUILD: HF6M</span>
    </div>

    <!-- 固定ヒント／固定フェード -->
    <div id="railHint" class="rail-hint" aria-hidden="true">⇠ スライド ⇢</div>
    <div class="rail-fade left"  aria-hidden="true"></div>
    <div class="rail-fade right" aria-hidden="true"></div>
  </div>

  <!-- 右：固定 -->
  <div class="right-fixed">
    <button class="btn" id="btnMore">⋯</button>
  </div>
</header>

<!-- ⋯の中身 -->
<div id="morePanel">
  <button class="btn" id="btnPrev_m">◀︎ 前</button>
  <div style="text-align:center;color:#fff;margin:4px 0">ページ <span id="pageIndicator_m">1/1</span></div>
  <button class="btn" id="btnNext_m">次 ▶︎</button>
  <hr style="border:none;border-top:1px solid #ffffff24;margin:6px 0">
  <button class="btn" id="btnAddPage_m">＋ページ</button>
  <button class="btn" id="btnSetBg_m">画像を背景に設定</button>
</div>

<aside class="sidebar" id="sidebar">
  <div class="rail">
    <button class="tool" id="btnSidebarToggle" data-tool="toggle" title="ツールバーの開閉">
      <svg viewBox="0 0 24 24"><path d="M5 15 L12 7 L19 15 M19 15 L5 15"/></svg>
    </button>
    <button class="tool" data-tool="pen" title="ペン">
      <svg viewBox="0 0 24 24"><path d="M3 21l4-1 12-12-3-3L4 17l-1 4zM14 6l3 3"/></svg>
    </button>
    <button class="tool" data-tool="marker" title="マーカー">
      <svg viewBox="0 0 24 24"><path d="M3 16l10-10 5 5-10 10-5 1 1-6zM13 6l5 5"/></svg>
    </button>
    <button class="tool" data-tool="eraser" title="消しゴム">
      <svg viewBox="0 0 24 24"><path d="M3 15l8-8 6 6-6 6H7zM13 7l4 4"/></svg>
    </button>
    <button class="tool" data-tool="hand" title="選択/パン">
      <svg viewBox="0 0 24 24"><path d="M9 11V6a2 2 0 0 1 4 0v5M13 11V5a2 2 0 1 1 4 0v8M9 11a2 2 0 0 1 4 0v8l-2 2-4-4-2-6 2-1z"/></svg>
    </button>
    <button class="tool" data-tool="keyboard" title="テキスト">
      <svg viewBox="0 0 24 24"><rect x="3" y="7" width="18" height="10" rx="2"></rect><path d="M7 10h10M5 13h14"/></svg>
    </button>
    <button class="tool" data-tool="settings" title="ツール設定（表示/非表示）">
      <svg viewBox="0 0 24 24"><path d="M12 7.5a4.5 4.5 0 1 1 0 9 4.5 4.5 0 0 1 0-9zM4 13h2l1 2-1 2H4l-1-2 1-2zm14 0h2l1 2-1 2h-2l-1-2 1-2zM8 4h2l2 1 2-1h2l1 2-1 2h-2l-2-1-2 1H8L7 6l1-2z"/></svg>
    </button>
  </div>
</aside>

<div class="panel" id="panel">
  <div class="handle" id="panelHandle">
    <div id="panelTool">-</div>
    <button class="close" id="panelClose">☒</button>
  </div>
  <div class="row"><label>色</label><input type="color" id="uiColor" value="#000000"></div>
  <div class="row" id="rowSize"><label>太さ</label><input type="range" min="1" max="60" value="4" id="uiSize"><span id="uiSizeVal">4px</span></div>
  <div class="row" id="rowAlpha"><label>不透明度</label><input type="range" min="10" max="100" value="50" id="uiAlpha"><span id="uiAlphaVal">50%</span></div>
  <div class="row" id="rowLineCap"><label>端の形</label>
    <select id="uiCap"><option value="butt">□ 角</option><option value="round" selected>● 丸</option></select>
  </div>
  <div class="row" id="rowStraight"><label>直線モード</label>
    <label><input type="checkbox" id="uiStraight">（モバイル / 15°刻み）</label>
    <label><input type="checkbox" id="uiGridFirst">グリッド優先</label>
  </div>
  <div class="row" id="rowGrid"><label>グリッド</label>
    <label><input type="checkbox" id="uiGrid"> 表示</label>
    <select id="uiGridStep"><option value="5">5mm</option><option value="10" selected>10mm</option><option value="15">15mm</option></select>
    <input type="color" id="uiGridColor" value="#b7bfd6"/>
  </div>
  <div class="row" id="rowPenExt">
    <label>ペン拡張</label>
    <label><input type="checkbox" id="uiPalm" checked> パーム除外</label>
    <label><input type="checkbox" id="uiPressure" checked> 圧力</label>
    <label><input type="checkbox" id="uiTilt" checked> 傾き</label>
  </div>
  <div class="row" id="rowTextOps" style="display:none;gap:6px">
    <label>テキスト</label>
    <button id="btnTextAdd">追加</button>
    <button id="btnTextBold">太字</button>
    <button id="btnTextIt">斜体</button>
    <button id="btnTextDel">選択削</button>
    <button id="btnTextBoxDel">枠削</button>
  </div>
</div>

<div id="wrap"><div id="stage">
  <div id="viewport">
    <canvas id="paper"></canvas>
    <canvas id="guide"></canvas>
    <canvas id="paint"></canvas>
    <div class="text-layer" id="textLayer"></div>
  </div>
</div></div>

<script>
/* util */
const $=s=>document.querySelector(s), $$=s=>Array.from(document.querySelectorAll(s));
const DPR=Math.max(1, self.devicePixelRatio||1);

/* nodes */
const topbar=$('#topbar'), panel=$('#panel'), viewport=$('#viewport');
const cvPaper=$('#paper'), gPaper=cvPaper.getContext('2d');
const cvGuide=$('#guide'), gGuide=cvGuide.getContext('2d');
const cv=$('#paint'), ctx=cv.getContext('2d',{alpha:true});
const textLayer=$('#textLayer');

/* version */
$('#verText').textContent='NOTE LINK — V0.8.0 / B-REL6-M';
$('#buildText').textContent='BUILD: HF6M';

/* layout */
let zoom=1, panX=0, panY=0, W=0, H=0;
function applyBars(){ const h=Math.round(topbar.getBoundingClientRect().height)||44; document.documentElement.style.setProperty('--topbar-h',h+'px'); }
function updateViewportTransform(){
  const tx=panX/zoom, ty=panY/zoom;
  viewport.style.transform=`scale(${zoom}) translate(${tx}px,${ty}px)`;
}
function fitCanvases(){
  const vr=viewport.getBoundingClientRect();
  W=Math.max(1, Math.round(vr.width));
  H=Math.max(1, Math.round(vr.height));
  for(const c of [cvPaper,cvGuide,cv]){
    c.width=Math.round(W*DPR); c.height=Math.round(H*DPR);
    c.style.width=W+'px'; c.style.height=H+'px';
  }
  layoutPaper(); drawPaper(); redrawAll();
}
addEventListener('resize',()=>{applyBars(); fitCanvases();});
if (window.visualViewport){ visualViewport.addEventListener('resize', ()=>{ applyBars(); fitCanvases(); }); }
addEventListener('orientationchange', ()=>{ applyBars(); fitCanvases(); });
applyBars();

/* paper */
function mm2px(mm){return mm*96/25.4*DPR}
const A4={wmm:210,hmm:297};
let paperRect={x:0,y:0,w:0,h:0};
function layoutPaper(){
  const a4w=mm2px(A4.wmm), a4h=mm2px(A4.hmm);
  const scale=Math.min(cv.width*0.65/a4w, cv.height*0.9/a4h);
  const w=a4w*scale, h=a4h*scale;
  paperRect={w,h,x:(cv.width-w)/2,y:(cv.height-h)/2};
}
let gridOn=false, gridStepMM=10, gridColor='#b7bfd6';
function drawPaper(){
  const g=gPaper; g.clearRect(0,0,cvPaper.width,cvPaper.height);
  g.fillStyle='#0b1020'; g.fillRect(0,0,cvPaper.width,cvPaper.height);
  const pg=Pages.cur();
  g.fillStyle='#fff'; g.fillRect(paperRect.x,paperRect.y,paperRect.w,paperRect.h);
  if(pg.bg && pg.bg.img){ g.drawImage(pg.bg.img,paperRect.x,paperRect.y,paperRect.w,paperRect.h); }
  if(gridOn){
    const step=Math.max(2, Math.round(mm2px(gridStepMM)*(paperRect.h/mm2px(A4.hmm))));
    g.save(); g.strokeStyle=gridColor+'88'; g.lineWidth=1*DPR; g.beginPath();
    for(let y=paperRect.y+step; y<=paperRect.y+paperRect.h-step; y+=step){ g.moveTo(paperRect.x,y); g.lineTo(paperRect.x+paperRect.w,y); }
    g.stroke(); g.restore();
  }
}

/* pages */
const Pages={ list:[{strokes:[],textsHTML:'',bg:null}], idx:0, cur(){ return this.list[this.idx]; } };
function setPage(i){
  i=Math.max(0, Math.min(Pages.list.length-1, i));
  Pages.cur().textsHTML=textLayer.innerHTML;
  Pages.idx=i;
  textLayer.innerHTML=Pages.cur().textsHTML||'';
  updatePageIndicator(); drawPaper(); redrawAll();
}
function updatePageIndicator(){
  $('#pageIndicator').textContent=(Pages.idx+1)+'/'+Pages.list.length;
  $('#pageIndicator_m').textContent=(Pages.idx+1)+'/'+Pages.list.length;
}
$('#btnPrev').onclick=()=>setPage(Pages.idx-1);
$('#btnNext').onclick=()=>setPage(Pages.idx+1);
$('#btnPrev_m').onclick=()=>{ setPage(Pages.idx-1); toggleMore(false); };
$('#btnNext_m').onclick=()=>{ setPage(Pages.idx+1); toggleMore(false); };
addEventListener('keydown',e=>{ if(e.key==='ArrowLeft') setPage(Pages.idx-1); if(e.key==='ArrowRight') setPage(Pages.idx+1); });

/* more panel */
const morePanel=$('#morePanel'); const btnMore=$('#btnMore');
function toggleMore(on){ morePanel.style.display=on?'block':'none'; }
btnMore.onclick=()=>toggleMore(morePanel.style.display!=='block');
addEventListener('click',e=>{ if(!morePanel.contains(e.target) && e.target!==btnMore) toggleMore(false); });
$('#btnAddPage_m').onclick=()=>{ const pos=Pages.idx+1; Pages.list.splice(pos,0,{strokes:[],textsHTML:'',bg:null}); setPage(pos); pushHistory(); toggleMore(false); };
$('#btnSetBg_m').onclick=async()=>{ const file=await pickImage(); if(!file) return;
  const tmp=new Image(); tmp.src=URL.createObjectURL(file);
  await new Promise(r=>{ tmp.onload=r; tmp.onerror=r; });
  const bg=fitImageToPaper(tmp); URL.revokeObjectURL(tmp.src);
  Pages.cur().bg=bg; drawPaper(); redrawAll(); pushHistory(); toggleMore(false);
};

/* tools */
let tool='pen';
const perTool={ pen:{color:'#000000',size:4,alpha:1,cap:'round',straight:false},
  marker:{color:'#ffff00',size:16,alpha:.5,cap:'butt',straight:false},
  eraser:{size:24}, hand:{}, keyboard:{} };
let color=perTool.pen.color, size=perTool.pen.size, alpha=1, cap='round';
let straightToggle=false, straightKey=false;
let palmReject=true, pressureOn=true, tiltOn=true;

function saveToolState(k){const p=perTool[k]||(perTool[k]={}); p.color=color;p.size=size;p.alpha=alpha;p.cap=cap;p.straight=!!straightToggle;}
function loadToolState(k){const p=perTool[k]||{};color=p.color??color;size=p.size??size;alpha=p.alpha??alpha;cap=p.cap??cap;straightToggle=!!p.straight;}
function setActiveTool(t){
  saveToolState(tool); tool=t; loadToolState(t);
  $$('.tool').forEach(b=>b.classList.toggle('active', b.dataset.tool===t));
  $('#panelTool').textContent=t;
  $('#rowAlpha').style.display=(t==='marker')?'':'none';
  $('#rowLineCap').style.display=(t==='marker'||t==='pen')?'':'none';
  $('#rowStraight').style.display=(t==='pen'||t==='marker')?'':'none';
  $('#rowTextOps').style.display=(t==='keyboard')?'':'none';
  $('#rowSize').style.display=(t==='pen'||t==='marker'||t==='eraser')?'':'none';
  $('#rowPenExt').style.display=(t==='pen'||t==='marker')?'':'none';
  syncUI();
  cv.style.cursor=(t==='hand')?'grab':'crosshair';
}
$('#btnSidebarToggle').onclick=()=>{ $('#sidebar').classList.toggle('collapsed'); };
$$('.tool').forEach(btn=>{
  if(btn.id==='btnSidebarToggle') return;
  btn.addEventListener('click',e=>{
    const t=btn.dataset.tool;
    if(t==='settings'){ const show=!panel.classList.contains('show'); panel.classList.toggle('show',show); btn.classList.toggle('active',show); return; }
    setActiveTool(t);
  });
});

/* panel */
(()=>{const handle=$('#panelHandle');let dragging=false,sx=0,sy=0,ox=0,oy=0,id=0;
function down(e){ if(e.target.closest('#panelClose')) return; dragging=true; id=e.pointerId||1; try{panel.setPointerCapture(id)}catch{}; sx=e.clientX; sy=e.clientY; const r=panel.getBoundingClientRect(); ox=r.left; oy=r.top; e.preventDefault();}
function move(e){ if(!dragging) return; const nx=ox+(e.clientX-sx),ny=oy+(e.clientY-sy); panel.style.left=Math.max(56,nx)+'px'; const top=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-h'))+6; panel.style.top=Math.max(top,ny)+'px';}
function up(){ dragging=false; try{panel.releasePointerCapture(id)}catch{} }
handle.addEventListener('pointerdown',down,{passive:false});
panel.addEventListener('pointermove',move,{passive:false});
panel.addEventListener('pointerup',up,{passive:false});
panel.addEventListener('pointercancel',up,{passive:false});
$('#panelClose').addEventListener('click',()=>{ panel.classList.remove('show'); $$('.tool[data-tool="settings"]').forEach(b=>b.classList.remove('active')); });
})();
const ui={color:$('#uiColor'),size:$('#uiSize'),alpha:$('#uiAlpha'),sizeVal:$('#uiSizeVal'),alphaVal:$('#uiAlphaVal'),cap:$('#uiCap'),straight:$('#uiStraight'),gOn:$('#uiGrid'),gStep:$('#uiGridStep'),gColor:$('#uiGridColor'),palm:$('#uiPalm'),pressure:$('#uiPressure'),tilt:$('#uiTilt')};
function pxToMm(px){return px*25.4/96}
function syncUI(){ui.color.value=color;ui.size.value=size;ui.sizeVal.textContent=`${size}px (${pxToMm(size).toFixed(2)} mm)`;ui.alpha.value=Math.round((tool==='marker'?alpha:0.5)*100);ui.alphaVal.textContent=Math.round((tool==='marker'?alpha:0.5)*100)+'%';ui.cap.value=cap;ui.straight.checked=straightToggle;ui.gOn.checked=gridOn;ui.gStep.value=String(gridStepMM);ui.gColor.value=gridColor;ui.palm.checked=palmReject;ui.pressure.checked=pressureOn;ui.tilt.checked=tiltOn;}
function onPanelChange(){color=ui.color.value;size=+ui.size.value;alpha=(tool==='marker')?(+ui.alpha.value/100):alpha;ui.sizeVal.textContent=`${size}px (${pxToMm(size).toFixed(2)} mm)`;ui.alphaVal.textContent=Math.round(alpha*100)+'%';cap=ui.cap.value;straightToggle=ui.straight.checked;gridOn=ui.gOn.checked;gridStepMM=+ui.gStep.value;gridColor=ui.gColor.value;drawPaper();redrawAll();}
Object.values(ui).forEach(el=>el.addEventListener('input',onPanelChange));

/* pointer mapping */
function pointerToCanvas(e){
  const r=cv.getBoundingClientRect();
  return { x:(e.clientX - r.left)*(cv.width/r.width), y:(e.clientY - r.top)*(cv.height/r.height) };
}
function inPaperXY(x,y){ return x>=paperRect.x && y>=paperRect.y && x<=paperRect.x+paperRect.w && y<=paperRect.y+paperRect.h; }

/* draw */
let drawing=false, panning=false, start={x:0,y:0}, last={x:0,y:0}, activeTouches=0;
let currentStroke=null;
function setCtx(){
  ctx.lineJoin='round'; ctx.lineCap=(tool==='marker'||tool==='pen')?cap:'round';
  if(tool==='eraser'){ ctx.globalCompositeOperation='destination-out'; ctx.strokeStyle='#000'; ctx.globalAlpha=1; }
  else if(tool==='marker'){ ctx.globalCompositeOperation='source-over'; ctx.strokeStyle=color; ctx.globalAlpha=alpha; }
  else { ctx.globalCompositeOperation='source-over'; ctx.strokeStyle=color; ctx.globalAlpha=1; }
  ctx.lineWidth=Math.max(1, Math.round(size*DPR));
}
function showGuide(sx,sy,ex,ey){
  gGuide.clearRect(0,0,cvGuide.width,cvGuide.height);
  gGuide.save(); gGuide.setLineDash([6*DPR,6*DPR]); gGuide.lineWidth=Math.max(1,Math.round(size*DPR));
  gGuide.lineCap=cap; gGuide.strokeStyle='#7ec8ff';
  gGuide.beginPath(); gGuide.moveTo(sx,sy); gGuide.lineTo(ex,ey); gGuide.stroke(); gGuide.restore();
}
function clearGuide(){ gGuide.clearRect(0,0,cvGuide.width,cvGuide.height); }

function toUV(x,y){ return {u:(x-paperRect.x)/paperRect.w, v:(y-paperRect.y)/paperRect.h}; }
function fromUV(u,v){ return {x:paperRect.x + u*paperRect.w, y:paperRect.y + v*paperRect.h}; }

function onDown(e){
  if(e.pointerType==='touch') activeTouches++;
  if(tool==='hand'){ panning=true; cv.style.cursor='grabbing'; return; }
  if($('#uiPalm').checked && e.pointerType==='touch' && activeTouches>1){ return; }
  const p=pointerToCanvas(e); if(!inPaperXY(p.x,p.y)) return;
  e.preventDefault(); try{cv.setPointerCapture(e.pointerId)}catch{}
  drawing=true; start=last=p; clearGuide();
  currentStroke={tool:(tool==='marker'?'marker':tool==='eraser'?'eraser':'pen'),
    color:(tool==='marker'||tool==='pen')?color:'#000000', alpha:(tool==='marker')?alpha:1, cap:cap,
    sizeU:(size/paperRect.h), pts:[toUV(p.x,p.y)]
  };
}
function onMove(e){
  if(tool==='hand' && panning){ panX+=e.movementX||0; panY+=e.movementY||0; updateViewportTransform(); return; }
  if(!drawing) return;
  const p=pointerToCanvas(e);
  const straight=(straightKey||$('#uiStraight').checked);
  if(straight){ showGuide(start.x,start.y,p.x,p.y); return; }
  const evs=(e.getCoalescedEvents&&e.getCoalescedEvents())||[e];
  setCtx(); ctx.beginPath(); ctx.moveTo(last.x,last.y);
  for(const ev of evs){
    const q=pointerToCanvas(ev);
    if(!inPaperXY(q.x,q.y)) continue;
    ctx.lineTo(q.x,q.y);
    currentStroke.pts.push(toUV(q.x,q.y));
    last=q;
  }
  ctx.stroke();
}
function onUp(e){
  if(e.pointerType==='touch') activeTouches=Math.max(0,activeTouches-1);
  if(tool==='hand' && panning){ panning=false; cv.style.cursor='grab'; return; }
  if(!drawing){ clearGuide(); return; }
  const p=pointerToCanvas(e);
  const straight=(straightKey||$('#uiStraight').checked);
  if(straight){
    setCtx(); ctx.beginPath(); ctx.moveTo(start.x,start.y); ctx.lineTo(p.x,p.y); ctx.stroke();
    currentStroke.pts.push(toUV(p.x,p.y));
  }
  drawing=false; clearGuide();
  if(currentStroke && currentStroke.pts.length>1){ Pages.cur().strokes.push(currentStroke); pushHistory(); }
  currentStroke=null;
}
cv.addEventListener('pointerdown',onDown,{passive:false});
cv.addEventListener('pointermove',onMove,{passive:false});
cv.addEventListener('pointerup',onUp,{passive:false});
cv.addEventListener('pointercancel',onUp,{passive:false});
addEventListener('keydown',e=>{ if(e.key==='Shift') straightKey=true; });
addEventListener('keyup',e=>{ if(e.key==='Shift') straightKey=false; });

function redrawAll(){
  ctx.clearRect(0,0,cv.width,cv.height);
  ctx.save(); ctx.beginPath(); ctx.rect(paperRect.x,paperRect.y,paperRect.w,paperRect.h); ctx.clip();
  for(const st of Pages.cur().strokes){
    const w=st.sizeU*paperRect.h;
    ctx.lineJoin='round'; ctx.lineCap=st.cap||'round';
    ctx.globalCompositeOperation=(st.tool==='eraser')?'destination-out':'source-over';
    ctx.globalAlpha=(st.tool==='marker')?(st.alpha??0.5):1.0;
    ctx.strokeStyle=(st.tool==='pen'||st.tool==='marker')?(st.color||'#000'):'#000';
    ctx.lineWidth=Math.max(1,Math.round(w));
    const p0=fromUV(st.pts[0].u,st.pts[0].v);
    ctx.beginPath(); ctx.moveTo(p0.x,p0.y);
    for(let i=1;i<st.pts.length;i++){ const pi=fromUV(st.pts[i].u,st.pts[i].v); ctx.lineTo(pi.x,pi.y); }
    ctx.stroke();
  }
  ctx.restore();
}

/* text */
function addText(){const el=document.createElement('div');el.className='note-text';el.contentEditable='true';
  el.style.left=(paperRect.x/DPR+20)+'px'; el.style.top=(paperRect.y/DPR+20)+'px'; el.textContent='テキスト';
  const del=document.createElement('button');del.className='del';del.textContent='削除';del.addEventListener('click',()=>el.remove());
  el.appendChild(del); textLayer.appendChild(el); el.focus(); pushHistory();
  el.addEventListener('focus',()=>{ cv.style.pointerEvents='none'; });
  el.addEventListener('blur', ()=>{ cv.style.pointerEvents='auto'; });
  el.addEventListener('pointerdown',e=>e.stopPropagation());
}
$('#btnTextAdd').onclick=addText;
$('#btnTextBold').onclick=()=>document.execCommand('bold',false,null);
$('#btnTextIt').onclick=()=>document.execCommand('italic',false,null);
$('#btnTextDel').onclick=()=>document.execCommand('delete',false,null);
$('#btnTextBoxDel').onclick=()=>{const sel=window.getSelection();if(!sel.rangeCount)return;let el=sel.anchorNode;while(el&&!(el instanceof HTMLElement&&el.classList.contains('note-text')))el=el.parentNode;if(el)el.remove();};

/* output */
function composite(){
  const out=document.createElement('canvas'); out.width=cv.width; out.height=cv.height; const o=out.getContext('2d');
  o.drawImage(cvPaper,0,0); o.drawImage(cv,0,0);
  [...textLayer.querySelectorAll('.note-text')].forEach(n=>{
    const r=n.getBoundingClientRect(), L=textLayer.getBoundingClientRect();
    const x=((r.left-L.left)*(cv.width/(L.width||1))), y=((r.top-L.top)*(cv.height/(L.height||1)));
    o.fillStyle='#111'; o.font=(16*DPR)+'px system-ui'; o.fillText(n.textContent.replace(/削除$/,''),x,y+16*DPR);
  });
  return out;
}
$('#btnPng').onclick=()=>composite().toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='note-link.png';a.click();setTimeout(()=>URL.revokeObjectURL(a.href),800)});
$('#btnPrint').onclick=()=>window.print();
$('#btnShare').onclick=()=>{composite().toBlob(async b=>{const f=new File([b],'note.png',{type:'image/png'});if(navigator.share&&navigator.canShare&&navigator.canShare({files:[f]})){try{await navigator.share({files:[f],title:'Note Link'})}catch(e){}}else{const u=URL.createObjectURL(b);const a=document.createElement('a');a.href=u;a.download='note-link.png';a.click();setTimeout(()=>URL.revokeObjectURL(u),800)}})};

/* save/load */
let fileHandle=null;
function exportJSON(){
  return JSON.stringify({
    v:'HF6m',
    pages: Pages.list.map(pg=>({strokes:pg.strokes||[],textsHTML:pg.textsHTML||'', bg:pg.bg && pg.bg.dataURL ? {dataURL:pg.bg.dataURL}:null})),
    idx: Pages.idx,
    grid:{on:gridOn,stepMM:gridStepMM,color:gridColor}
  });
}
async function doSave(){
  const blob=new Blob([exportJSON()],{type:'application/json'});
  try{
    if('showSaveFilePicker' in window){
      if(!fileHandle){
        fileHandle=await window.showSaveFilePicker({suggestedName:'note-link.json',types:[{description:'Note Link JSON',accept:{'application/json':['.json']}}]});
      }
      const w=await fileHandle.createWritable(); await w.write(blob); await w.close();
    }else{
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='note-link.json'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),800);
    }
  }catch(e){}
}
async function doLoad(){
  try{
    let f=null;
    if('showOpenFilePicker' in window){
      const [h]=await window.showOpenFilePicker({types:[{description:'Note Link JSON',accept:{'application/json':['.json']}}]});
      f=await h.getFile(); fileHandle=h;
    }else{
      const inp=document.createElement('input'); inp.type='file'; inp.accept='.json,application/json';
      f=await new Promise(res=>{ inp.onchange=()=>res(inp.files[0]); inp.click(); });
    }
    const txt=await f.text(); const data=JSON.parse(txt);
    Pages.list=(data.pages||[]).map(pg=>{ const entry={strokes:pg.strokes||[],textsHTML:pg.textsHTML||'',bg:null};
      if(pg.bg && pg.bg.dataURL){ const img=new Image(); img.src=pg.bg.dataURL; entry.bg={dataURL:pg.bg.dataURL,img}; }
      return entry;
    });
    if(!Pages.list.length) Pages.list=[{strokes:[],textsHTML:'',bg:null}];
    Pages.idx=Math.max(0,Math.min(Pages.list.length-1,data.idx||0));
    gridOn=!!data.grid?.on; gridStepMM=data.grid?.stepMM||10; gridColor=data.grid?.color||'#b7bfd6';
    textLayer.innerHTML=Pages.cur().textsHTML||'';
    updatePageIndicator(); drawPaper(); redrawAll(); pushHistory();
  }catch(e){}
}
$('#btnSave').onclick=doSave; $('#btnLoad').onclick=doLoad;

/* image add/insert */
async function pickImage(){
  try{
    if('showOpenFilePicker' in window){
      const [h]=await window.showOpenFilePicker({types:[{description:'JPEG/PNG',accept:{'image/*':['.jpg','.jpeg','.png']}}]});
      return await h.getFile();
    }else{
      const inp=document.createElement('input'); inp.type='file'; inp.accept='image/jpeg,image/png';
      return await new Promise(res=>{ inp.onchange=()=>res(inp.files[0]); inp.click(); });
    }
  }catch(e){ return null; }
}
function fitImageToPaper(img){
  const off=document.createElement('canvas'); off.width=Math.round(paperRect.w); off.height=Math.round(paperRect.h);
  const o=off.getContext('2d');
  const sc=Math.min(off.width/img.naturalWidth, off.height/img.naturalHeight);
  const w=img.naturalWidth*sc, h=img.naturalHeight*sc, x=(off.width-w)/2, y=(off.height-h)/2;
  o.fillStyle='#fff'; o.fillRect(0,0,off.width,off.height); o.drawImage(img,x,y,w,h);
  const dataURL=off.toDataURL('image/jpeg',0.9); const fitted=new Image(); fitted.src=dataURL;
  return {dataURL, img:fitted};
}
async function addImage(mode){
  const file=await pickImage(); if(!file) return;
  const tmp=new Image(); tmp.src=URL.createObjectURL(file);
  await new Promise(r=>{ tmp.onload=r; tmp.onerror=r; });
  const bg=fitImageToPaper(tmp); URL.revokeObjectURL(tmp.src);
  if(mode==='append'){ Pages.list.push({strokes:[],textsHTML:'',bg}); setPage(Pages.list.length-1); }
  else { const pos=Pages.idx+1; Pages.list.splice(pos,0,{strokes:[],textsHTML:'',bg}); setPage(pos); }
  pushHistory();
}
$('#btnImgAppend').onclick=()=>addImage('append');
$('#btnImgInsert').onclick=()=>addImage('insert');

/* undo/redo */
const hist=[], redoStack=[];
function snapshot(){ return {pages:JSON.parse(JSON.stringify(Pages.list.map(p=>({strokes:p.strokes,textsHTML:p.textsHTML,bg:p.bg?{dataURL:p.bg.dataURL}:null})))), idx:Pages.idx, grid:{on:gridOn,step:gridStepMM,color:gridColor}}; }
function pushHistory(){ hist.push(snapshot()); if(hist.length>40) hist.shift(); redoStack.length=0; updatePageIndicator(); }
function restoreSnap(s){
  Pages.list=s.pages.map(pg=>{ const entry={strokes:pg.strokes||[],textsHTML:pg.textsHTML||'',bg:null}; if(pg.bg&&pg.bg.dataURL){ const img=new Image(); img.src=pg.bg.dataURL; entry.bg={dataURL:pg.bg.dataURL,img}; } return entry; });
  Pages.idx=Math.max(0,Math.min(Pages.list.length-1,s.idx||0));
  gridOn=s.grid.on; gridStepMM=s.grid.step; gridColor=s.grid.color;
  textLayer.innerHTML=Pages.cur().textsHTML||''; updatePageIndicator(); drawPaper(); redrawAll();
}
$('#btnUndo').onclick=()=>{ if(!hist.length) return; const cur=snapshot(); const prev=hist.pop(); redoStack.push(cur); restoreSnap(prev); };
$('#btnRedo').onclick=()=>{ const nxt=redoStack.pop(); if(!nxt) return; hist.push(snapshot()); restoreSnap(nxt); };

/* zoom */
function setZoom(z){
  const z0=zoom, z1=Math.max(0.6,Math.min(3,z));
  const vrW=viewport.clientWidth, vrH=viewport.clientHeight;
  const Cx=vrW/2, Cy=vrH/2;
  const Ux=(Cx - panX)/z0, Uy=(Cy - panY)/z0;
  zoom=z1;
  panX = Cx - Ux*z1;
  panY = Cy - Uy*z1;
  updateViewportTransform();
  $('#btnZoomReset').textContent=Math.round(zoom*100)+'%';
}
$('#btnZoomIn').onclick = ()=>setZoom(zoom+0.1);
$('#btnZoomOut').onclick= ()=>setZoom(zoom-0.1);
$('#btnZoomReset').onclick=()=>setZoom(1);

/* boot */
function boot(){
  updateViewportTransform();
  fitCanvases();
  setActiveTool('pen');
  panel.classList.remove('show'); $$('.tool[data-tool="settings"]').forEach(b=>b.classList.remove('active'));
  pushHistory();
}
boot();

/* === HF6K: 横スクロール（wheel/drag） === */
const rail = document.getElementById('railScroll');
rail.addEventListener('wheel', (e) => {
  const useY = Math.abs(e.deltaY) >= Math.abs(e.deltaX);
  const delta = useY ? e.deltaY : e.deltaX;
  if (delta !== 0) { rail.scrollLeft += delta; e.preventDefault(); }
}, { passive:false });
let railDown=false, railDrag=false, railStartX=0, railStartLeft=0;
const DRAG_THRESHOLD=5;
rail.addEventListener('pointerdown', (e) => {
  if (e.button !== 0 && e.pointerType === 'mouse') return;
  railDown=true; railDrag=false; railStartX=e.clientX; railStartLeft=rail.scrollLeft;
  rail.setPointerCapture?.(e.pointerId);
});
rail.addEventListener('pointermove', (e) => {
  if (!railDown) return;
  const dx=e.clientX-railStartX;
  if (!railDrag && Math.abs(dx)>DRAG_THRESHOLD){ railDrag=true; rail.classList.add('dragging'); }
  if (railDrag){ rail.scrollLeft=railStartLeft-dx; e.preventDefault(); }
},{passive:false});
function railEnd(e){ if(railDown&&railDrag) e.preventDefault(); railDown=false; railDrag=false; rail.classList.remove('dragging'); try{rail.releasePointerCapture?.(e.pointerId);}catch{} }
rail.addEventListener('pointerup',railEnd,{passive:false});
rail.addEventListener('pointercancel',railEnd,{passive:false});
rail.addEventListener('pointerleave',railEnd,{passive:true});

/* === HF6M: オーバーフロー検知＋ヒント（wrapに付与） === */
(function enhanceRailDiscoverability(){
  const rail = document.getElementById('railScroll');
  const wrap = document.getElementById('railWrap');
  const hint = document.getElementById('railHint');
  if(!rail || !wrap || !hint) return;

  function updateOverflowState(){
    const can = rail.scrollWidth > rail.clientWidth + 1;
    wrap.classList.toggle('can-overflow', can);
    const sc = rail.scrollLeft;
    const max = rail.scrollWidth - rail.clientWidth - 1;
    wrap.classList.toggle('at-start', sc <= 0);
    wrap.classList.toggle('at-end',   sc >= max);
  }

  function maybeShowHint(){
    let shown = false;
    try{ shown = sessionStorage.getItem('railHinted') === '1'; }catch{}
    if(shown) return;
    if(wrap.classList.contains('can-overflow')){
      hint.classList.add('show');
      setTimeout(()=>{
        hint.classList.remove('show');
        try{ sessionStorage.setItem('railHinted','1'); }catch{}
      }, 2200);
    }
  }

  const dismissHint = ()=>{
    hint.classList.remove('show');
    try{ sessionStorage.setItem('railHinted','1'); }catch{}
  };

  rail.addEventListener('scroll', updateOverflowState, {passive:true});
  rail.addEventListener('wheel',  dismissHint, {passive:true});
  rail.addEventListener('pointerdown', dismissHint, {passive:true});
  window.addEventListener('resize', ()=>{ updateOverflowState(); maybeShowHint(); });

  updateOverflowState();
  maybeShowHint();
})();
</script>
</body>
</html>
